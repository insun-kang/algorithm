#문제

```
가장 큰 부분합 구하기
정수들의 리스트가 입력으로 들어옵니다. 이 정수들의 리스트를 일부분만 잘라내어 모두 더했을 때의 값을 부분합이라 부릅니다. 이때 가장 큰 부분합을 구해봅시다.

예를 들어, [-10, -7, 5, -7, 10, 5, -2, 17, -25, 1]이 입력으로 들어왔다면 [10, 5, -2, 17]을 모두 더한 30이 정답이 됩니다.

※입력에는 최소 하나 이상의 양수가 존재합니다.

※이 문제에는 여러 종류의 풀이법이 존재합니다. 각 풀이법의 시간 복잡도를 고려하면서 여러가지 방법으로 문제를 풀어 봅시다.
```

#풀이 방법

가장 큰 부분합을 구하는 방법에는 4가지가 있다고 한다.

1. 완전탐색 O(2^n)

2. 부분합 배열 이용 O(n^2)

3. 분할정복 O(nlog2(n))

4. 동적 계획법 O(n)

이 중에서 **동적 계획법**이 가장 무난한 방법!!

    먼저 주어진 배열과 같은 크기의 배열을 선언해준다.(ans)
    주어진 배열의 값이 0보다 큰 부분에서 시작을 해야하기에 max(0, ans[i-1])을 사용...이것은 다음 인덱스 값과의 합이 0보다 큰 것을 골라내는데도 이용된다.
    ans에서 가장 큰 값을 뽑아내준다.

#코드
```

def maxSubArray(nums):
    ans=[0]*len(nums)
    
    ans[0]=nums[0]
    
    for i in range(1, len(nums)):
        ans[i]=max(0, ans[i-1])+nums[i]
    print(ans)
    return max(ans)
    


def main():
    print(maxSubArray([-10, -7, 5, -7, 10, 5, -2, 17, -2, 1])) # 30이 리턴되어야 합니다

if __name__ == "__main__":
    main()
    ```
